# 浏览器渲染过程

## 加载与构建

浏览器会顺序解析 HTML。

遇到外部资源会发起请求。

JS 默认会阻塞解析，可以配置 async 和 defer 实现异步执行。

等待外部资源获取完毕，HTML 会被解析成一个 DOM 树，CSS 会被解析成一个 CSSOM 树，两者合并一个渲染树。

## 渲染阶段

计算布局。

绘制元素。

## 示例

假设有一段 HTML 代码。

```html
<div>
  <h1>Hello, world!</h1>
  <p>This is a paragraph.</p>
</div>
```

```text
div
├── h1
│   └── "Hello world!"
└── p
    └── "This is a paragraph"
```

另有一段 CSS 代码。

```css
div {
  width: 400px;
  padding: 20px;
  border: 2px solid black;
  background-color: lightgray;
}

h1 {
  color: red;
  font-size: 24px;
  font-weight: bold;
}

p {
  color: blue;
  font-size: 16px;
  line-height: 1.5;
}
```

它会生成类似下面的 CSSOM 树：

```text
Stylesheet
├── div
│   ├── width: 400px
│   ├── padding: 20px;
│   ├── border: 2px solid black;
│   └── background-color: lightgray;
├── h1
│   ├── color: red;
│   ├── font-size: 24px;
│   └── font-weight: bold;
└── p
    ├── color: blue;
    ├── font-size: 16px;
    └── line-height: 1.5;
```

DOM 树和 CSSOM 树合并就会形成类似下面这种结构：

```text
Render Tree
├── div (width: 400px, padding: 20px, border: 2px solid black, background: lightgray)
├── h1 (color: red, font-size: 24px, font-weight: bold)
└── p (color: blue, font-size: 16px, line-height: 1.5)
```

## 性能优化

### 减少 DOM 操作

使用浏览器的队列化特性，减少或合并一些队列操作。

比如 DocumentFragment 来优化节点插入性能。

### 使用 CSS 原生动画

尽量使用 CSS 动画而不是 JS 动画。能够使用 GPU 进行运算。

### 懒加载

对于图片和视频可以采用来加载的方式优化性能。

### 任务分流

使用 Web Worker 进行任务分流。

## 参考资料

### 网络资源

[【前端面试】5分钟搞懂浏览器渲染流程：DOM+CSSOM=渲染树](https://www.bilibili.com/video/BV1k5oCYrE81)

### 本地链接

[DOM 树](./DOM树.md)

[DocumentFragment](./DocumentFragment.md)
