# 算法

## 画图分析

### 回溯法画图

以这段代码为例，我们来画图描述算法步骤：

```ts
function subsets(nums: number[]): number[][] {
  let path = [];
  let res = [];

  function backtrack(startIndex: number) {
    if (startIndex === nums.length) {
      res.push([...path]);
      return;
    }
    path.push(nums[startIndex]);
    backtrack(startIndex+1);
    path.pop()
    backtrack(startIndex+1);
  }

  backtrack(0);
  return res;
};
```

![20250805160716](https://kat-tc.oss-cn-chengdu.aliyuncs.com/20250805160716.png)

主要的依据还是代码，初始有一个 `bt(0)` 表示的是最初的调用 `backtrack(0)`。

![20250805160922](https://kat-tc.oss-cn-chengdu.aliyuncs.com/20250805160922.png)

然后执行 `bt(0)` 里面的代码，左边的矩形表示执行的代码内容，可以看到箭头上是 `push` 的元素。执行了 `backtrack(1)` 之后，生成一个 `bt(1)` 节点。

![20250805161152](https://kat-tc.oss-cn-chengdu.aliyuncs.com/20250805161152.png)

这里描述执行 `bt(1)` 内部的代码之后，生成了 `bt(2)`。以此类推直至完成算法。

## 题库

### 版本号排序

版本号的数字用 `.` 号分割。

输入：`['1.6.1', '1.6']`

输出：`['1.6', '1.6.1']`

代码：

```js
function sortVersionNumber(versions: string[]) {
  versions.sort(cmp);
}

function cmp(a: string, b: string) {
  let arr1 = a.split('.').map(Number);
  let arr2 = b.split('.').map(Number);
  const n = Math.max(a.length, b.length);
  for (let i = 0; i < n; i++) {
    let num1 = arr1[i] ?? 0;
    let num2 = arr2[i] ?? 0;
    if (num1 > num2) return 1;
    else if (num1 < num2) return -1;
    else continue;
  }
  return 0;
}

const versions = ['1.0.1', '2.0.1', '1.1.2', '4.1.5', '4.2.1']
sortVersionNumber(versions);  // ['1.0.1', '1.1.2', '2.0.1', '4.1.5', '4.2.1']
```
